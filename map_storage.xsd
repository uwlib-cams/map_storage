<?xml version="1.0" encoding="UTF-8"?>
<!-- are both targetNamespace and xmlns attrs needed? -->
<xs:schema targetNamespace="https://uwlib-cams.github.io/map_storage/"
    xmlns="https://uwlib-cams.github.io/map_storage/" xmlns:xs="http://www.w3.org/2001/XMLSchema"
    xmlns:vc="http://www.w3.org/2007/XMLSchema-versioning" elementFormDefault="qualified"
    vc:minVersion="1.1">

    <xs:import namespace="http://www.w3.org/XML/1998/namespace"
        schemaLocation="http://www.w3.org/2001/03/xml.xsd"/>
    <!-- [?] xs:import below results in error -->
    <xs:import namespace="http://www.w3.org/2001/XMLSchema"
        schemaLocation="https://www.w3.org/2001/XMLSchema.xsd"/>

    <!-- ******************* prop_set ******************* -->
    <xs:element name="prop_set" type="prop_set_type"/>

    <xs:complexType name="prop_set_type">
        <xs:sequence>
            <xs:element name="prop" type="prop_type" minOccurs="1" maxOccurs="unbounded"/>
        </xs:sequence>
        <xs:attribute name="mapid_prop_set" type="mapid_prop_set_attr_type"/>
    </xs:complexType>

    <xs:simpleType name="mapid_prop_set_attr_type">
        <!-- = uwl_sinopia_maps.xsd > prop_set_type -->
        <xs:restriction base="xs:string">
            <!-- (MAP ID component) -->
            <!-- [?] is it possible to put enumeration lists that will need updating, like this one, in an external doc and import here as vars, etc.? 
                See map_storage #5 -->
            <xs:enumeration value="rdacWork"/>
            <xs:enumeration value="rdacExpression"/>
            <xs:enumeration value="rdacManifestation"/>
            <!-- Not yet in test storage instance
            <xs:enumeration value="rdacIPropSet"/>
            <xs:enumeration value="rdacAPropSet"/>
            <xs:enumeration value=""/>
            -->
        </xs:restriction>
    </xs:simpleType>

    <!-- ****************** prop ****************** -->
    <xs:complexType name="prop_type">
        <xs:sequence>
            <xs:element name="prop_iri" type="iri_type" minOccurs="1" maxOccurs="1"/>
            <xs:element name="prop_label" type="lang_string_type" minOccurs="1"
                maxOccurs="unbounded"/>
            <xs:element name="prop_domain" type="iri_type" minOccurs="0" maxOccurs="unbounded"/>
            <xs:element name="prop_range" type="iri_type" minOccurs="0" maxOccurs="unbounded"/>
            <!-- CONSIDER creating additional elements so that URLs can be stored for 1) output as ref links to appear in Sinopia UI and
                2) output as ref links with descriptive text to appear in HTML -->
            <xs:element name="prop_related_url" type="url_type" minOccurs="0" maxOccurs="unbounded"/>
            <xs:element name="sinopia" type="sinopia_type" minOccurs="0" maxOccurs="1"/>
        </xs:sequence>
        <xs:attribute name="localid_prop" type="localid_attr" use="required"/>
    </xs:complexType>

    <!-- REUSE -->
    <xs:complexType name="iri_type">
        <xs:attribute name="iri">
            <xs:simpleType>
                <xs:restriction base="xs:anyURI">
                    <!-- IRI validation pattern -->
                    <xs:pattern value="https?:\/\/\S*"/>
                </xs:restriction>
            </xs:simpleType>
        </xs:attribute>
    </xs:complexType>

    <!-- REUSE -->
    <xs:simpleType name="localid_attr">
        <xs:restriction base="xs:string">
            <!-- Possible to an XSD mechanism to prevent duplicate values? -->
            <!-- Possible to provide constraints *and* a default? See map_storage #6 -->
            <!-- A default in the case of localid_[...] attrs would allow users to enter a "placeholder" localid during source editing 
                and avoid validation errors; then unique localid values would be added with XSLT or Python after source editing -->
            <xs:pattern value="\S+"/>
        </xs:restriction>
    </xs:simpleType>

    <!-- REUSE -->
    <xs:complexType name="lang_string_type">
        <!-- to do: need default "en" -->
        <!-- also to do confirm use of correct lang-tag set (is there a rule for XML?? see below) -->
        <xs:simpleContent>
            <xs:extension base="xs:string">
                <!-- Use values from https://www.iana.org/assignments/language-subtag-registry/language-subtag-registry  -->
                <xs:attribute ref="xml:lang" use="required"/>
                <!-- xsd: to do / wishlist / question: possible to add enumerations here?? -->
                <!-- en -->
                <!-- zxx -->
            </xs:extension>
        </xs:simpleContent>
    </xs:complexType>

    <!-- prop_domain: iri_type defined above -->
    <!-- prop_range: iri_type defined above -->

    <!-- BMR TO DO [!] This element needs work; attributes need better constraints -->
    <xs:complexType name="url_type">
        <xs:simpleContent>
            <!-- Need to improve constraints on URL values here; xs:anyURI alone not effective -->
            <xs:extension base="xs:anyURI">
                <xs:attribute name="url"/>
                <!-- Use values to differentiate 1) output as ref links to appear in Sinopia UI vs. 2) output as ref links with descriptive text to appear in HTML -->
                <!-- Need to enumerate link_category, one category should be remark URL -->
                <xs:attribute name="link_category"/>
                <!-- Maybe store link text as text child, not in @ -->
                <xs:attribute name="link_text"/>
            </xs:extension>

        </xs:simpleContent>
    </xs:complexType>

    <!-- **************** sinopia **************** -->
    <xs:complexType name="sinopia_type">
        <xs:sequence>
            <xs:element name="implementation_set" type="implementation_set_type" minOccurs="1"
                maxOccurs="unbounded"/>
        </xs:sequence>
    </xs:complexType>

    <!-- *************** implementation_set *************** -->
    <xs:complexType name="implementation_set_type">
        <xs:sequence>
            <xs:element name="resource" type="resource_type" minOccurs="1" maxOccurs="unbounded"/>
            <!-- Resource templates such as Agent, Timespan, etc. may not need format specs, so minOccurs should be 0? -->
            <xs:element name="format" type="format_type" minOccurs="0" maxOccurs="unbounded"/>
            <xs:element name="user" type="user_type" minOccurs="0" maxOccurs="unbounded"/>
            <xs:element name="multiple_prop" type="multiple_prop_type" minOccurs="0" maxOccurs="1"/>
            <xs:element name="form_order" type="form_order_type" minOccurs="1" maxOccurs="1"/>
            <xs:element name="remark" type="lang_string_type" minOccurs="0" maxOccurs="1"/>
            <xs:element name="sinopia_prop_attributes" type="sinopia_prop_attributes_type"
                minOccurs="1" maxOccurs="1"/>
        </xs:sequence>
        <xs:attribute name="localid_implementation_set" type="localid_attr" use="required"/>
    </xs:complexType>

    <xs:complexType name="resource_type">
        <xs:attribute name="mapid_resource" type="mapid_resource_attr_type" use="required"/>
    </xs:complexType>

    <!-- Various mapid_[...] attributes will not be re-usable;
        many will need regular updates as new prop_sets/formats/users/ are added -->
    <xs:simpleType name="mapid_resource_attr_type">
        <!-- = uwl_sinopia_maps.xsd > resource_type -->
        <xs:restriction base="xs:string">
            <!-- (MAP ID component) -->
            <!-- For prop sets from RDA Registry, mapid_prop_set and mapid_resource values will be redundant 
            (RDA Work property set properties for use in an RDA Work RT), 
            but this may not be the case for other vocabularies -->
            <xs:enumeration value="rdacWork"/>
            <xs:enumeration value="rdacExpression"/>
            <xs:enumeration value="rdacManifestation"/>
            <!-- enumeration below for testing -->
            <xs:enumeration value="testMultiplePropSets"/>
            <!-- Not yet in test storage instance
            <xs:enumeration value="rdacItem"/>
            <xs:enumeration value="rdacAgent"/>
            <xs:enumeration value=""/>
            -->
        </xs:restriction>
    </xs:simpleType>

    <xs:simpleType name="format_type">
        <!-- = uwl_sinopia_maps.xsd > format_type -->
        <xs:restriction base="xs:string">
            <!-- (MAP ID component) -->
            <!-- mapid enumerations here will need updating -->
            <xs:enumeration value="monograph"/>
            <!-- below are for testing, to do delete from schema later -->
            <xs:enumeration value="test_literal_props"/>
            <xs:enumeration value="test_uri_or_lookup_props"/>
            <xs:enumeration value="test_nested_resource_props"/>
            <xs:enumeration value="test_all_props"/>
        </xs:restriction>
    </xs:simpleType>

    <xs:simpleType name="user_type">
        <!-- = uwl_sinopia_maps.xsd > user_type -->
        <xs:restriction base="xs:string">
            <!-- (MAP ID component) -->
            <!-- mapid enumerations here will need updating -->
            <xs:enumeration value="default"/>
            <xs:enumeration value="ries07"/>
            <xs:enumeration value="mcm104"/>
        </xs:restriction>
    </xs:simpleType>

    <xs:complexType name="multiple_prop_type">
        <xs:annotation>
            <xs:documentation>The 'multiple_prop' element is used to create a drop-down property list in the property template.</xs:documentation>
            <xs:documentation>When using the resource template, users can select from among the drop-down properties for use.</xs:documentation>
            <xs:documentation>To include all subproperties of the 'prop' element property in the drop-down, use the 'multiple_prop' > 'all_subprops' child element, and enter the value 'true'.</xs:documentation>
            <xs:documentation>To select properties to include in the drop-down, use 'property' elements (as many as needed) to provide property IRIs and labels.</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:choice>
                <xs:element name="all_subprops" type="xs:boolean" minOccurs="1" maxOccurs="1"/>
                <xs:element name="property" type="property_selection_type" minOccurs="1" maxOccurs="unbounded"/>
            </xs:choice>
        </xs:sequence>
    </xs:complexType>
    
    <!-- to do: constrain further, require text element content -->
    <xs:complexType name="property_selection_type">
        <xs:annotation>
            <xs:documentation>Enter a property label as the text content of the 'property' element.</xs:documentation>
            <xs:documentation>Enter the full, non-prefixed property IRI as the content of the 'property_iri' attribute.</xs:documentation>
        </xs:annotation>
        <xs:simpleContent>
            <xs:extension base="xs:string">
                <xs:attribute name="property_iri" type="xs:anyURI" use="required"/>
                <xs:attribute ref="xml:lang" use="required"/>            
            </xs:extension>
        </xs:simpleContent>
    </xs:complexType>

    <!-- TO DO / xsd question: how to allow prop_info element only if
        @prop_selection = 'select_props' -->
    <xs:complexType name="prop_info_type">
        <xs:sequence>
            <xs:element name="prop_option_iri" type="iri_type" minOccurs="1" maxOccurs="1"/>
            <xs:element name="prop_option_label" type="lang_string_type" minOccurs="1" maxOccurs="1"
            />
        </xs:sequence>
    </xs:complexType>

    <xs:simpleType name="form_order_type">
        <xs:restriction base="xs:decimal">
            <xs:minInclusive value="0.0"/>
            <xs:maxInclusive value="1.0"/>
        </xs:restriction>
    </xs:simpleType>

    <!-- remark: lang_string_type defined above -->

    <!-- ************ sinopia_prop_attributes ************ -->
    <xs:complexType name="sinopia_prop_attributes_type">
        <xs:sequence>
            <!-- if language_suppressed == 1 *and* default literal has @xml:lang will anything break?? -->
            <xs:element name="language_suppressed" type="xs:boolean" minOccurs="0" maxOccurs="1" default="0"/>
            <xs:element name="required" type="xs:boolean" minOccurs="0" maxOccurs="1" default="0"/>
            <xs:element name="repeatable" type="xs:boolean" minOccurs="0" maxOccurs="1" default="0"/>
            <!-- to do: wishlist [?] ordered = true|1 should *only* be allowable if repeatable = true|1; is this possible? -->
            <xs:element name="ordered" type="xs:boolean" minOccurs="0" maxOccurs="1" default="0"/>
            <xs:element name="sinopia_prop_type" type="sinopia_prop_type_type" minOccurs="1"
                maxOccurs="1"/>
            <xs:element name="sinopia_prop_type_attributes" type="sinopia_prop_type_attributes_type"
                minOccurs="1" maxOccurs="1"/>
        </xs:sequence>
    </xs:complexType>

    <xs:simpleType name="sinopia_prop_type_type">
        <xs:restriction base="xs:string">
            <!-- Double-check that I'm up on the current Sinopia property type choices! -->
            <xs:enumeration value="literal"/>
            <xs:enumeration value="uri_or_lookup"/>
            <xs:enumeration value="nested_resource"/>
        </xs:restriction>
    </xs:simpleType>

    <!-- *********** sinopia_prop_type_attributes *********** -->
    <xs:complexType name="sinopia_prop_type_attributes_type">
        <!-- to do / xsd wish list: allow one of following based on value of sinopia_prop_type_type above -->
        <xs:choice>
            <xs:element name="literal_attributes" type="literal_attributes_type" minOccurs="1"
                maxOccurs="1"/>
            <xs:element name="uri_attributes" type="uri_attributes_type" minOccurs="1" maxOccurs="1"/>
            <xs:element name="lookup_attributes" type="lookup_attributes_type" minOccurs="1"
                maxOccurs="1"/>
            <xs:element name="nested_resource_attributes" type="nested_resource_attributes_type"
                minOccurs="1" maxOccurs="1"/>
        </xs:choice>
    </xs:complexType>

    <!-- ********** literal_attributes ********** -->
    <xs:complexType name="literal_attributes_type">
        <xs:sequence>
           <xs:element name="default_literal" type="lang_string_type" minOccurs="1" maxOccurs="1"/>
            <xs:choice>
                <xs:element name="validation_regex" type="validation_regex_type" minOccurs="0"
                    maxOccurs="1"/>
                <xs:element name="validation_datatype" type="validation_datatype_type" minOccurs="0"
                    maxOccurs="1"/>
                <xs:element name="date_default" type="xs:boolean" minOccurs="0"
                    maxOccurs="1"/>
                <xs:element name="userId_default" type="xs:boolean" minOccurs="0"
                    maxOccurs="1"/>
            </xs:choice>
        </xs:sequence>
    </xs:complexType>

    <!-- literal_attributes: lang_string_type defined above -->

    <xs:simpleType name="validation_regex_type">
        <xs:restriction base="xs:string">
            <!-- how to validate a regex as a regex!?!? -->
        </xs:restriction>
    </xs:simpleType>

    <xs:simpleType name="validation_datatype_type">
        <xs:restriction base="xs:string">
            <!-- can I have spaces in my enumerations?? -->
            <xs:enumeration value="Date and time with or without timezone"/>
            <xs:enumeration value="Date and time with required timezone"/>
            <xs:enumeration value="Extended Date/Time Format (EDTF)"/>
            <xs:enumeration value="Integer"/>
        </xs:restriction>
    </xs:simpleType>

    <!-- ********** uri_attributes ********** -->
    <xs:complexType name="uri_attributes_type">
        <xs:sequence>
            <xs:element name="default_uri" type="iri_type" minOccurs="1" maxOccurs="1"/>
            <xs:element name="default_uri_label" type="lang_string_type" minOccurs="0" maxOccurs="1"
            />
        </xs:sequence>
    </xs:complexType>

    <!-- default_uri: iri_type defined above -->
    <!-- default_uri_label: lang_string_type defined above -->

    <!-- ********** lookup_attributes ********** -->
    <xs:complexType name="lookup_attributes_type">
        <xs:sequence>
            <xs:element name="authorities" type="authorities_type" minOccurs="1"
                maxOccurs="unbounded"/>
            <xs:element name="lookup_default_iri" type="iri_type" minOccurs="1" maxOccurs="1"/>
            <xs:element name="lookup_default_iri_label" type="lang_string_type" minOccurs="0"
                maxOccurs="1"/>
        </xs:sequence>
    </xs:complexType>

    <xs:complexType name="authorities_type">
        <xs:sequence>
            <xs:element name="authority_urn" type="authority_urn_type" minOccurs="1"
                maxOccurs="unbounded"/>
        </xs:sequence>
    </xs:complexType>

    <xs:simpleType name="authority_urn_type">
        <xs:restriction base="xs:string">
            <!-- to do enumerate here -->
            <!-- Options: 
                1. Confirm that authorities URNs still come from 
                https://github.com/LD4P/sinopia_editor/blob/master/static/authorityConfig.json , grab from there
                enter all possible options in a test RT and copy URNs 
            -->
            <xs:enumeration value="urn:ld4p:sinopia"/>
            <xs:enumeration value="urn:ld4p:sinopia:bibframe:instance"/>
            <!-- ... lots still to add, starting from the top -->
            <xs:enumeration value="urn:ld4p:qa:names"/>
            <!-- ... -->
            <xs:enumeration value="urn:ld4p:qa:gettyulan"/>
        </xs:restriction>
    </xs:simpleType>

    <!-- lookup_default_iri: iri_type defined above -->
    <!-- lookup_default_iri_label: lang_string_type defined above -->

    <!-- ********** nested_resource_attributes ********** -->
    <xs:complexType name="nested_resource_attributes_type">
        <xs:sequence>
            <xs:element name="rt_id" type="rt_id_type"/>
        </xs:sequence>
    </xs:complexType>

    <xs:simpleType name="rt_id_type">
        <xs:restriction base="xs:string">
            <!-- UPDATING THESE ENUMERATIONS
            List of enumerations = list of all RT IDs
            see sinopia_maps.xml -->
            <!-- could RT IDs be taken from sinopia_maps.xml? see map_storage issue #5 -->
            <!-- the following is for testing to do delete later-->
            <xs:enumeration value="WAU:rdacAgent:rdacAgent:ries07"/>
        </xs:restriction>
    </xs:simpleType>

    <!-- *********** guidance *********** -->
    <!-- this may end up going elsewhere, a storage instance at uwl_sinopia_maps... -->

</xs:schema>
