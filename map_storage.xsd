<?xml version="1.0" encoding="UTF-8"?>
<!-- are both targetNamespace and xmlns attrs needed? -->
<xs:schema targetNamespace="https://uwlib-cams.github.io/map_storage/"
    xmlns="https://uwlib-cams.github.io/map_storage/" xmlns:xs="http://www.w3.org/2001/XMLSchema"
    xmlns:vc="http://www.w3.org/2007/XMLSchema-versioning" elementFormDefault="qualified"
    vc:minVersion="1.1">

    <xs:import namespace="http://www.w3.org/XML/1998/namespace"
        schemaLocation="http://www.w3.org/2001/03/xml.xsd"/>
    <!-- [?] xs:import below results in error -->
    <xs:import namespace="http://www.w3.org/2001/XMLSchema"
        schemaLocation="https://www.w3.org/2001/XMLSchema.xsd"/>

    <!-- ******************* propSet ******************* -->
    <xs:element name="propSet" type="propSet_type"/>

    <xs:complexType name="propSet_type">
        <xs:sequence>
            <xs:element name="prop" type="prop_type" minOccurs="1" maxOccurs="unbounded"/>
        </xs:sequence>
        <xs:attribute name="mapid_propSet" type="mapid_propSet_attr_type"/>
    </xs:complexType>

    <xs:simpleType name="mapid_propSet_attr_type">
        <!-- = uwl_sinopia_maps.xsd > propSet_type -->
        <xs:restriction base="xs:string">
            <!-- (MAP ID component) -->
            <!-- [?] is it possible to put enumeration lists that will need updating, like this one, in an external doc and import here as vars, etc.? 
                See map_storage #5 -->
            <xs:enumeration value="rdacWork"/>
            <xs:enumeration value="rdacExpression"/>
            <xs:enumeration value="rdacManifestation"/>
            <!-- Not yet in test storage instance
            <xs:enumeration value="rdacIPropSet"/>
            <xs:enumeration value="rdacAPropSet"/>
            <xs:enumeration value=""/>
            -->
        </xs:restriction>
    </xs:simpleType>

    <!-- ****************** prop ****************** -->
    <xs:complexType name="prop_type">
        <xs:sequence>
            <xs:element name="prop_iri" type="iri_type" minOccurs="1" maxOccurs="1"/>
            <xs:element name="prop_label" type="lang_string_type" minOccurs="1"
                maxOccurs="unbounded"/>
            <xs:element name="prop_domain" type="iri_type" minOccurs="0" maxOccurs="unbounded"/>
            <xs:element name="prop_range" type="iri_type" minOccurs="0" maxOccurs="unbounded"/>
            <!-- CONSIDER creating additional elements so that URLs can be stored for 1) output as ref links to appear in Sinopia UI and
                2) output as ref links with descriptive text to appear in HTML -->
            <xs:element name="prop_related_url" type="url_type" minOccurs="0" maxOccurs="unbounded"/>
            <xs:element name="sinopia" type="sinopia_type" minOccurs="0" maxOccurs="1"/>
        </xs:sequence>
        <xs:attribute name="localid_prop" type="localid_attr" use="required"/>
    </xs:complexType>
    
    <!-- REUSE -->
    <xs:complexType name="iri_type">
        <xs:attribute name="iri">
            <xs:simpleType>
                <xs:restriction base="xs:anyURI">
                    <!-- IRI validation pattern -->
                    <xs:pattern value="https?:\/\/\S*"/>
                </xs:restriction>
            </xs:simpleType>
        </xs:attribute>
    </xs:complexType>

    <!-- REUSE -->
    <xs:simpleType name="localid_attr">
        <xs:restriction base="xs:string">
            <!-- Possible to an XSD mechanism to prevent duplicate values? -->
            <!-- Possible to provide constraints *and* a default? See map_storage #6 -->
            <!-- A default in the case of localid_[...] attrs would allow users to enter a "placeholder" localid during source editing 
                and avoid validation errors; then unique localid values would be added with XSLT or Python after source editing -->
            <xs:pattern value="\S+"/>
        </xs:restriction>
    </xs:simpleType>

    <!-- REUSE -->
    <xs:complexType name="lang_string_type">
        <!-- to do: need default "en" -->
        <!-- also to do confirm use of correct lang-tag set (is there a rule for XML?? see below) -->
        <xs:simpleContent>
            <xs:extension base="xs:string">
                <!-- Use values from https://www.iana.org/assignments/language-subtag-registry/language-subtag-registry  -->
                <xs:attribute ref="xml:lang" use="required"/>
            </xs:extension>
        </xs:simpleContent>
    </xs:complexType>

    <!-- prop_domain: iri_type defined above -->
    <!-- prop_range: iri_type defined above -->

    <!-- BMR TO DO [!] This element needs work; attributes need better constraints -->
    <xs:complexType name="url_type">
        <xs:simpleContent>
            <!-- Need to improve constraints on URL values here; xs:anyURI alone not effective -->
            <xs:extension base="xs:anyURI">
                <xs:attribute name="url"/>
                <!-- Use values to differentiate 1) output as ref links to appear in Sinopia UI vs. 2) output as ref links with descriptive text to appear in HTML -->
                <!-- Need to enumerate link_category, one category should be remark URL -->
                <xs:attribute name="link_category"/>
                <!-- Maybe store link text as text child, not in @ -->
                <xs:attribute name="link_text"/>
            </xs:extension>

        </xs:simpleContent>
    </xs:complexType>

    <!-- **************** sinopia **************** -->
    <xs:complexType name="sinopia_type">
        <xs:sequence>
            <xs:element name="implementationSet" type="implementationSet_type" minOccurs="1"
                maxOccurs="unbounded"/>
        </xs:sequence>
    </xs:complexType>

    <!-- *************** implementationSet *************** -->
    <xs:complexType name="implementationSet_type">
        <xs:sequence>
            <xs:element name="resource" type="resource_type" minOccurs="1" maxOccurs="unbounded"/>
            <!-- Resource templates such as Agent, Timespan, etc. may not need format specs, so minOccurs should be 0? -->
            <xs:element name="format" type="format_type" minOccurs="0" maxOccurs="unbounded"/>
            <xs:element name="user" type="user_type" minOccurs="0" maxOccurs="unbounded"/>
            <xs:element name="multiple_prop" type="multiple_prop_type" minOccurs="0" maxOccurs="1"/>
            <xs:element name="form_order" type="form_order_type" minOccurs="1" maxOccurs="1"/>
            <xs:element name="remark" type="lang_string_type" minOccurs="0" maxOccurs="1"/>
            <xs:element name="sinopia_prop_attributes" type="sinopia_prop_attributes_type"
                minOccurs="1" maxOccurs="1"/>
        </xs:sequence>
        <xs:attribute name="localid_implementationSet" type="localid_attr" use="required"/>
    </xs:complexType>

    <xs:complexType name="resource_type">
        <xs:attribute name="mapid_resource" type="mapid_resource_attr_type" use="required"/>
    </xs:complexType>

    <!-- Various mapid_[...] attributes will not be re-usable;
        many will need regular updates as new propSets/formats/users/ are added -->
    <xs:simpleType name="mapid_resource_attr_type">
        <!-- = uwl_sinopia_maps.xsd > resource_type -->
        <xs:restriction base="xs:string">
            <!-- (MAP ID component) -->
            <!-- For prop sets from RDA Registry, mapid_propSet and mapid_resource values will be redundant 
            (RDA Work property set properties for use in an RDA Work RT), 
            but this may not be the case for other vocabularies -->
            <xs:enumeration value="rdacWork"/>
            <xs:enumeration value="rdacExpression"/>
            <xs:enumeration value="rdacManifestation"/>
            <!-- Not yet in test storage instance
            <xs:enumeration value="rdacItem"/>
            <xs:enumeration value="rdacAgent"/>
            <xs:enumeration value=""/>
            -->
        </xs:restriction>
    </xs:simpleType>

    <xs:simpleType name="format_type">
        <!-- = uwl_sinopia_maps.xsd > format_type -->
        <xs:restriction base="xs:string">
            <!-- (MAP ID component) -->
            <!-- mapid enumerations here will need updating -->
            <xs:enumeration value="monograph"/>
        </xs:restriction>
    </xs:simpleType>

    <xs:simpleType name="user_type">
        <!-- = uwl_sinopia_maps.xsd > user_type -->
        <xs:restriction base="xs:string">
            <!-- (MAP ID component) -->
            <!-- mapid enumerations here will need updating -->
            <xs:enumeration value="default"/>
            <xs:enumeration value="ries07"/>
            <xs:enumeration value="mcm104"/>
        </xs:restriction>
    </xs:simpleType>

    <xs:complexType name="multiple_prop_type">
        <xs:sequence>
            <xs:element name="prop_info" type="prop_info_type" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
        <!-- TO DO / xsd question: how to allow prop_info element only if
        @prop_selection = 'select_props' -->
        <xs:attribute name="prop_selection" type="prop_selection_attr"/>
    </xs:complexType>

    <xs:simpleType name="prop_selection_attr">
        <xs:restriction base="xs:string">
            <xs:enumeration value="all_subprops"/>
            <xs:enumeration value="select_props"/>
        </xs:restriction>
    </xs:simpleType>

    <!-- TO DO / xsd question: how to allow prop_info element only if
        @prop_selection = 'select_props' -->
    <xs:complexType name="prop_info_type">
        <xs:sequence>
            <xs:element name="prop_option_iri" type="iri_type" minOccurs="1" maxOccurs="1"/>
            <xs:element name="prop_option_label" type="lang_string_type" minOccurs="1" maxOccurs="1"
            />
        </xs:sequence>
    </xs:complexType>

    <xs:simpleType name="form_order_type">
        <xs:restriction base="xs:decimal">
            <xs:minInclusive value="0.0"/>
            <xs:maxInclusive value="1.0"/>
        </xs:restriction>
    </xs:simpleType>

    <!-- remark: lang_string_type defined above -->

    <!-- ************ sinopia_prop_attributes ************ -->
    <xs:complexType name="sinopia_prop_attributes_type">
        <xs:sequence>
            <xs:element name="required" type="boolean_type" minOccurs="1" maxOccurs="1"/>
            <xs:element name="repeatable" type="boolean_type" minOccurs="1" maxOccurs="1"/>
            <!-- to do: [?] ordered = true should *only* be allowable if repeatable = true; is this possible? -->
            <!-- also, related, empty element should be possible here -->
            <xs:element name="ordered" type="boolean_type" minOccurs="1" maxOccurs="1"/>
            <xs:element name="sinopia_prop_type" type="sinopia_prop_type_type" minOccurs="1"
                maxOccurs="1"/>
            <xs:element name="sinopia_prop_type_attributes" type="sinopia_prop_type_attributes_type"
                minOccurs="1" maxOccurs="1"/>
        </xs:sequence>
    </xs:complexType>

    <!-- REUSE -->
    <xs:simpleType name="boolean_type">
        <!-- to do: default false -->
        <!-- to do: why isn't CTRL + SPACE working for autocomplete?? -->
        <!-- to do : [?] what if a value is not provided? will an empty element result in validation error? it needs to -->
        <xs:restriction base="xs:boolean"/>
    </xs:simpleType>

    <xs:simpleType name="sinopia_prop_type_type">
        <xs:restriction base="xs:string">
            <!-- Double-check that I'm up on the current Sinopia property type choices! -->
            <xs:enumeration value="literal"/>
            <xs:enumeration value="uri_or_lookup"/>
            <xs:enumeration value="nested_resource"/>
        </xs:restriction>
    </xs:simpleType>

    <!-- *********** sinopia_prop_type_attributes *********** -->
    <xs:complexType name="sinopia_prop_type_attributes_type">
        <!-- still to do I think: require based on value of sinopia_prop_type_type above -->
        <xs:choice>
            <xs:element name="literal_attributes" type="literal_attributes_type" minOccurs="1"
                maxOccurs="1"/>
            <xs:element name="uri_attributes" type="uri_attributes_type" minOccurs="1" maxOccurs="1"/>
            <xs:element name="lookup_attributes" type="lookup_attributes_type" minOccurs="1"
                maxOccurs="1"/>
            <xs:element name="nested_resource_attributes" type="nested_resource_attributes_type"
                minOccurs="1" maxOccurs="1"/>
        </xs:choice>
    </xs:complexType>

    <!-- ********** literal_attributes ********** -->
    <xs:complexType name="literal_attributes_type">
        <xs:sequence>
            <xs:element name="default_literal" type="lang_string_type" minOccurs="1" maxOccurs="1"/>
            <!-- add validation_regex element -->
            <!-- add validation_datatype element -->
        </xs:sequence>
    </xs:complexType>

    <!-- literal_attributes: lang_string_type defined above -->

    <!-- ********** uri_attributes ********** -->
    <xs:complexType name="uri_attributes_type">
        <xs:sequence>
            <xs:element name="default_uri" type="iri_type" minOccurs="1" maxOccurs="1"/>
            <xs:element name="default_uri_label" type="lang_string_type" minOccurs="0" maxOccurs="1"
            />
        </xs:sequence>
    </xs:complexType>

    <!-- default_uri: iri_type defined above -->
    <!-- default_uri_label: lang_string_type defined above -->

    <!-- ********** lookup_attributes ********** -->
    <xs:complexType name="lookup_attributes_type">
        <xs:sequence>
            <xs:element name="authorities" type="authorities_type" minOccurs="1"
                maxOccurs="unbounded"/>
            <xs:element name="lookup_default_iri" type="iri_type" minOccurs="1" maxOccurs="1"/>
            <xs:element name="lookup_default_iri_label" type="lang_string_type" minOccurs="0"
                maxOccurs="1"/>
        </xs:sequence>
    </xs:complexType>

    <xs:complexType name="authorities_type">
        <xs:sequence>
            <xs:element name="authority_urn" type="authority_urn_type"/>
        </xs:sequence>
    </xs:complexType>

    <xs:simpleType name="authority_urn_type">
        <xs:restriction base="xs:string">
            <!-- to do enumerate here -->
            <!-- Options: 
                1. Confirm that authorities URNs still come from 
                https://github.com/LD4P/sinopia_editor/blob/master/static/authorityConfig.json , grab from there
                enter all possible options in a test RT and copy URNs 
            -->
            <xs:enumeration value="urn:ld4p:sinopia"/>
            <xs:enumeration value="urn:ld4p:sinopia:bibframe:instance"/>
            <!-- ... lots still to add, starting from the top -->
            <xs:enumeration value="urn:ld4p:qa:names"/>
            <!-- ... -->
            <xs:enumeration value="urn:ld4p:qa:gettyulan"/>
        </xs:restriction>
    </xs:simpleType>

    <!-- lookup_default_iri: iri_type defined above -->
    <!-- lookup_default_iri_label: lang_string_type defined above -->

    <!-- ********** nested_resource_attributes ********** -->
    <xs:complexType name="nested_resource_attributes_type">
        <xs:sequence>
            <xs:element name="rt_id" type="rt_id_type"/>
        </xs:sequence>
    </xs:complexType>

    <xs:simpleType name="rt_id_type">
        <xs:restriction base="xs:string">
            <xs:enumeration value="WAU:rda_Work:Work:monograph:ries07"/>
            <!-- TO DO UPDATING THESE ENUMERATIONS WILL BE VERY DIFFICULT; HOW TO DO THIS?
            List of enumerations = list of all RT IDs, RT IDs are comprised of mapid_[...] attribute-value combinations -->
            <!-- the following enumeration is for testing and should be deleted -->
            <!-- NOTE that uwl_sinopia_maps.xml now exists, could RT IDs be taken from here? see map_storage issue #5 -->
            <xs:enumeration value="WAU:rda_Agent:Agent:ries07"/>
        </xs:restriction>
    </xs:simpleType>

    <!-- *********** guidance *********** -->
    <!-- this may end up going elsewhere, a storage instance at uwl_sinopia_maps... -->

</xs:schema>
